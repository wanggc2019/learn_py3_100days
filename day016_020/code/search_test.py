#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""
数据结构和算法
算法：解决问题的方法和步骤

排序算法（选择、冒泡和归并）
查找算法（顺序和折半）
"""

"""
顺序查找
基本思想：
顺序查找，就是从第一个元素开始，按索引顺序遍历待查找序列，直到找出给定目标或者查找失败。
特点：
1. 对待查序列（表）无要求 -- 待查找序列可以是有序，也可以是无序；
2. 从第一个元素开始；
3. 需要逐一遍历整个待查序列（除非已经找到）；
4. 若查找到最后一个元素还没找到，则查找失败；

缺点：
效率低 -- 需要遍历整个待查序列

时间复杂度：
O(n)，平均查找时间 = 列表长度/2
空间复杂度：
1个待查序列+1个目标元素 <=> O(n)
"""


def seq_search(items, key):
    for index, item in enumerate(items):
        if item == key:
            # return index
            print(index, item)
    return -1


"""
折半查找（二分查找）
该算法的使用的前提是静态查找表中的数据必须是有序的。
1.定义3个用来记录索引值的变量，变量min记录当前范围最小索引值，初始值为0；变量max记录当前范围最大索引值，初始值为 数组长度-1；
变量mid记录当前当前范围最中间元素的索引值，初始值为(min+max) / 2
2.使用循环，判断当前范围下，最中间元素值与指定查找的数值是否相等
    若相等，结束循环，返回当前范围最中间元素的索引值mid
    若不相等，根据比较结果，缩小查询范围为上一次查询范围的一半：
        中间元素值 比 要查询的数值大，说明要查询的数值在当前范围的最小索引位置与中间索引位置之间，此时，更新查询范围为:范围最大索引值 = 上一次中间索引位置 -1；
        中间元素值 比 要查询的数值小，说明要查询的数值在当前范围的最大索引位置与中间索引位置之间，此时，更新查询范围为:范围最小索引值 = 上一次中间索引位置 +1；
        在新的查询范围中，更新中间元素值的位置，再次使用最中间元素值与指定查找的数值是否相等。中间索引值 = (范围最小索引值 +范围最大索引值) / 2;
3.每次查询范围缩小一半后，使用if语句判断，查询范围是否小于0个元素，若小于0个元素，则说明指定数值没有查询到，返回索引值-1。
"""


def half_search(items, key):
    # 可理解为指针
    # 起始位置 0
    start = 0
    # 最大索引，因为len是长度，索引是从0开始，所以减1
    end = len(items) - 1
    # 结束就是2个指针重合
    while start < end:
        # 中间索引 要整除
        mid = (start + end) // 2
        # 如果中间值小于key，则要找的值大于mid，那么范围落在mid 和end之间，start指针移动mid + 1
        if items[mid] < key:
            start = mid + 1
        # 如果中间值大于key，则要找的值小于mid，那么范围落在 start 和mid之间，end指针移动mid - 1
        elif items[mid] > key:
            end = mid - 1
        else:
            return mid
    return -1


if __name__ == '__main__':
    lst1 = [1, 2, 3, 4, 5, 7, 8, 9]
    lst2 = ['wgc', 4, '李四', 78.98, '赵武']
    # seq_search(lst2, '李四')
    half_search(lst1, 9)


